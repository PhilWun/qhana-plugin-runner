{% import 'forms.html' as forms %}

<html>

<head>
    <link rel="stylesheet" type="text/css" href="{{url_for('static', filename='forms.css')}}" media="screen" />
</head>

<body>
    <div class="qhana-microfrontend">
        {% if help_text or example_values %}
        <details class="qhana-help">
            <summary>Help</summary>
            {% if help_text %}
            {% autoescape false %}
            {{help_text | markdown}}
            {% endautoescape %}
            {% else %}
            <br>
            {% endif %}
            {% if example_values %}
            <a href="{{example_values}}">Fill in example values.</a>
            {% endif %}
        </details>
        {% endif %}
        {% call forms.render_form(target="microfrontend") %}
        {{ forms.render_fields(schema, values=values, errors=errors) }}
        <div class="qhana-form-buttons">
            {{ forms.submit("validate", target="microfrontend")}}
            {{ forms.submit("submit", action=process)}}
            {% if done %}
            {{ forms.submit("done", action=done)}}
            {% endif %}
        </div>
        {% endcall %}
    </div>

    <script src="{{url_for('static', filename='microfrontend.js')}}"></script>

</body>

</html>

<script>
    var pca_type_menu = document.getElementById("pca_type");
    var kernel_type_menu = document.getElementById("kernel");

    var entity_points_url = document.getElementById("entity_points_url").parentNode.parentNode;
    var solver = document.getElementById("solver").parentNode.parentNode;
    var batch_size = document.getElementById("batch_size").parentNode.parentNode;
    var sparsity_alpha = document.getElementById("sparsity_alpha").parentNode.parentNode;
    var ridge_alpha = document.getElementById("ridge_alpha").parentNode.parentNode;
    var kernel = kernel_type_menu.parentNode.parentNode;
    var kernel_url = document.getElementById("kernel_url").parentNode.parentNode;
    var degree = document.getElementById("degree").parentNode.parentNode;
    var kernel_gamma = document.getElementById("kernel_gamma").parentNode.parentNode;
    var kernel_coef = document.getElementById("kernel_coef").parentNode.parentNode;
    var max_itr = document.getElementById("max_itr").parentNode.parentNode;
    var tol = document.getElementById("tol").parentNode.parentNode;
    var iterated_power = document.getElementById("iterated_power").parentNode.parentNode;


    // If the pca type is the KernelPCA, then we can choose a type of kernel, e.g. linear
    // Different kernel types need different input parameters
    function kernel_type_change() {
        kernel_coef.style.display = 'none';
        degree.style.display = 'none';
        kernel_gamma.style.display = 'none';
        kernel_url.style.display = 'none';
        if (kernel_type_menu.value === "poly") {
            kernel_coef.style.display = 'block';
            degree.style.display = 'block';
            kernel_gamma.style.display = 'block';
        }
        else if (kernel_type_menu.value === "rbf") {
            kernel_gamma.style.display = 'block';
        }
        else if (kernel_type_menu.value === "sigmoid") {
            kernel_coef.style.display = 'block';
            kernel_gamma.style.display = 'block';
        }
        else if (kernel_type_menu.value === "precomputed") {
            kernel_url.style.display = 'block';
            entity_points_url.style.display = 'none';
        }
    }


    function hide_all() {
        solver.style.display = 'none';
        batch_size.style.display = 'none';
        sparsity_alpha.style.display = 'none';
        ridge_alpha.style.display = 'none';
        kernel.style.display = 'none';
        kernel_url.style.display = 'none';
        degree.style.display = 'none';
        kernel_gamma.style.display = 'none';
        kernel_coef.style.display = 'none';
        max_itr.style.display = 'none';
        tol.style.display = 'none';
        iterated_power.style.display = 'none';
    }

    function show_normal() {
        solver.style.display = 'block';
        tol.style.display = 'block';
        iterated_power.style.display = 'block';
    }

    function show_incremental() {
        solver.style.display = 'block';
        batch_size.style.display = 'block';
    }

    function show_sparse() {
        solver.style.display = 'block';
        sparsity_alpha.style.display = 'block';
        ridge_alpha.style.display = 'block';
        max_itr.style.display = 'block';
        tol.style.display = 'block';
    }

    function show_kernel() {
        kernel.style.display = 'block';
        // The following parameters in comments belong to the KernalPCA, but only specific kernels use them.
        // Therefor, kernel_type_change() manages their visibility
        // kernel_coef.style.display = 'block';
        // degree.style.display = 'block';
        // kernel_gamma.style.display = 'block';
        // kernel_url.style.display = 'block';

        solver.style.display = 'block';
        tol.style.display = 'block';
        iterated_power.style.display = 'block';
    }

    hide_all();
    show_normal();

    function pca_type_change() {
        hide_all();
        entity_points_url.style.display = 'block';
        if (pca_type_menu.value === "normal") {
            show_normal();
        }
        else if (pca_type_menu.value === "incremental") {
            show_incremental();
        }
        else if (pca_type_menu.value === "sparse") {
            show_sparse();
        }
        else if (pca_type_menu.value === "kernel") {
            show_kernel();
            kernel_type_change();
        }
    }

    pca_type_menu.onchange = pca_type_change;
    kernel_type_menu.onchange = kernel_type_change;
</script>
